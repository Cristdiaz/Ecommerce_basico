D√≠as: 11 y 12 de julio.

1. CREAR EL PROYECTO:
rails new Ecommerce
cd Ecommerce

Si queremos programar en espa√±ol debemos ir a config/initializers/inflections.rb
Ah√≠ pondremos en singular y en plural las palabras en espa√±ol que utilizaremos,
o copiaremos el contenido del initializer de este proyecto para poder programar TODO en
espa√±ol, no solo algunos datos. 


2. Hacer las tablas:

rails g scaffold Category name:string
Revisar migraciones db/migrate/   que todo est√© bien, el uso de plural y singular y adem√°s los datos 
de la tabla y sus tipos. 
rails db:migrate

rails g scaffold Product name:string description:text stock:integer
price:decimal sku:string
Al igual que el anterior revisar el contenido de la migraci√≥n, corregir lo necesario y luego dar:
rails db:migrate


3. Relacionar ambas tablas con HABTM.

Crear una tabla join que sea el conector entre ambos modelos y agregar la instrucci√≥n 
has_and_belongs_to_many en cada uno de los modelos involucrados.

a. Creamos la tabla intermedia que unir√° a la otras 2:
rails g migration CreateJoinTableProductCategory product category
As√≠ deber√≠a quedar este archivo:

class CreateJoinTableProductCategory < ActiveRecord::Migration[5.2]
    def change  
        create_join_table :products, :categories do |t|
        t.index [:product_id, :category_id]
        t.index [:category_id, :product_id]
        end
    end
end

rails db:migrate

b.  Editaremos los modelos Product y Category de tal
manera que agregaremos has_and_belongs_to_many a cada uno de ellos.

app/models/product.rb

class Product < ApplicationRecord
    has_and_belongs_to_many :categories
end

app/models/category.rb

class Category < ApplicationRecord
    has_and_belongs_to_many :products
end

c. Ir al localhost:3000 y verificar que solo hay un formulario de producto, pero no categor√≠as.

d.Ir a vista _form.html.erb de los productos y agregaremos la siguiente porci√≥n de
c√≥digo que sirve de conector con las categor√≠as.

<div class="field">
    <%= form.label :categories %>
        <%= form.collection_check_boxes(:category_ids,
                                        Category.all,
                                        :id,
                                        :name) do |b| %>
        <%= b.label class:"label-checkbox" do%>
            <%=b.check_box + b.text%>
        <%end%>
    <% end %>
</div>

e. Para que estos cambios sean guardados, debemos agregar en el controlador la instrucci√≥n
necesaria para poder recibir los par√°metros asociados a las categor√≠as. Debemos recordar
que Rails filtra los par√°metros que recibe desde el formulario para evitar problemas de
seguridad asociados a la asignaci√≥n de par√°metros. Agregaremos a los strong params
category_ids para que sean procesados en el controlador. Editaremos el controlador de
productos y el m√©todo product_params quedar√° como sigue:

app/controllers/products_controller.rb

class ProductsController < ApplicationController
before_action :set_product, only: [:show, :edit, :update, :destroy]

...

private
    
    def product_params
        params.require(:product).permit(:name, :description, :stock,
    :price, :sku, {category_ids: []})
    end
end



2. ALMACENAR DATOS PREDERTERMINADOS:

Usando archivos Ruby podemos agregar datos que ser√°n insertados en la base
de datos usando el comando Rails db:seed. Ser√°n los datos iniciales con los que comenzaremos.

a. Es una buena pr√°ctica separar en otros archivos seeds seg√∫n el contexto
y cada uno de estos archivos ser invocados desde el archivo seeds.rb.
Hacemos para esto una nueva carpeta llamada seeds, y en ella haremos los 
archivos para introducir nuestros datos por separado. Los que ser√°n
involucrados desde el archivo seeds.rb. Generamos en la nueva carpetaun archivo para
categorias y otro para productos.

As√≠ creamos desde consola nuestra nueva carpeta:

mkdir db/seeds

b. Luego crearemos el archivo categories.rb dentro del directorio reci√©n creado y agregaremos
el siguiente contenido:

db/seeds/categories.rb

Category.create(name: "Pasteles")
Category.create(name: "Galleta")
Category.create(name: "Gelatina")
Category.create(name: "Boller√≠a")

c. Luego crearemos un nuevo archivo en el mismo directorio llamado products.rb y agregaremos el
siguiente contenido:

db/seeds/products.rb

category_1 = Category.find_by(name: "Pasteles")

p_01 = Product.create(name: "Panqueque de naranja", description: "con mermelada de naranja", stock: 10, price: 900, sku: "AIX0120")
p_01.categories << category_1

(As√≠ podemos crear 10 productos m√°s)

El archivo db/seeds/products.rb nos permite crear un producto y a la vez asignarle la
categor√≠a. 

d. Para unir estos dos archivos y relaciionar estos contenidos vamos a:
db/seeds.rb

y agregamos el siguiente c√≥digo:
Dir[File.join(Rails.root, 'db', 'seeds', '*.rb')].sort.each { |seed|
load seed }

e. Ejecutar rails db:seed

f. Revisar el localhost:3000, ah√≠ deber√≠amos tener todos los datos ingresados



3. PROTEGER NUESTROS RECURSOS CON LA GEMA DEVISE.

AUTHENTICATION es el procedimiento para que solo algunos usuarios puedan acceder acceder
distintas vistas de nuestro proyecto, y sus funciones tambi√©n se vena limitadas.
Ac√° lo haremos con DEVISE

a. En Gemfile:  gem "devise" agregar al final del doc.
bundle
rails generate devise:install

Y seguir los pasos que aparecen en consola para terminar de instalar.

a. Pegar en config/environment/development.rb el link del paso 1.
b. Pegar en app/views/layouts/application.html.erb los 2 rails del paso 2 dentro del body sobre yield.
c. En config/routes.rb poner root 'home#index' como p√°gina central,
   no est√° habilitado a√∫n.

b. Generaremos la Bd para los administradores del proyecto:

rails generate (o g) devise Administrador (funciona como un scaffold)
rails db:migrate
rails s
localhost:3000/admins/sign_in   --> pantalla login para administradores


c. Para proteger los recursos y que solo los administradores puedan operar sobre ellos,
modificaremos el archivo routes.rb y utilizaremos una de las tantas funcionalidades que
tiene Devise. Nuestro archivo de rutas quedar√° como sigue:

Rails.application.routes.draw do
    devise_for :admins
    root to: "home#index"
    
    authenticate :admin do
        resources :products
        resources :categories
    end

    # For details on the DSL available within this file, see
    http://guides.rubyonrails.org/routing.html
end

De esta manera, cuando alguien ingresa a alguno de los recursos sin estar logueado, la
persona es redirigida al formulario de login para administradores.



3. ESTRUCTURANDO EL E-COMMERCE:

Tenemos los modelos Categor√≠as y Productos, pero nos falta todo lo relacionado al proceso de compras y el carro.
Tenemos que hacer dos modelos nuevos, Order que representa el carro o la orden de compra y Usuario, que es quien
realizar√° la compra. 

a. Hacemos el mismo procedimiento anterior con devise para crear la vista del Usuario que realizar√° la compra:

rails g devise Usuario
rails db:migrate

b. Hacer el modelo de Orden: 

rails g model Order user:references number:string total:decimal
state:string
rails db:migrate











###################DIA 3#####################
        PONER EL CARRO DE COMPRAS

Primero agregamos en el test:

 test 'No agregar productos con 0 stock' do
    # Preparar
    usuario = Usuario.create(email: 'usuario@correo.com', password: '1q2we34r')
    orden = Orden.create(usuario_id: usuario.id)
    producto_sin_stock = Producto.create(nombre: 'testp1', precio: 1, stock: 0, sku: 'CM003')
    # Actuar / Ejecutar
    orden.agregar_producto(producto_sin_stock.id, 1)
    # Asertar
    assert_equal orden.detalles_ordenes.count, 0
  end





En app/models/orden.rb

def agregar_producto(id_producto, cantidad)
    producto = Producto.find(id_producto)
    if producto && producto.stock > 0 #cambio para que no se pueda vender producto con stock 0
      detalles_ordenes.create(
        producto_id: producto.id, 
        cantidad: cantidad,
        precio: producto.precio
      )
    end
end






Crear un nuevo controller para el carro:
app/controllers/carros_controllers.rb

  def update
        producto = params[:carro][:producto_id]
        cantidad = params[:carro][:cantidad]

        orden_actual.agregar_producto(producto, cantidad)

        redirect_to root_url, notice: 'Producto agregado ü§ë'
    end

    def show
        @orden = orden_actual
    end




Luego en app/controllers/application_controller.rb agregamos:

    def orden_actual
        if current_usuario # preguntar con devise si tenemos una sesi√≥n
            orden = Orden.where(usuario_id: current_usuario.id).where(estado: 'creado').last
            if orden.nil?
                orden = Orden.create(usuario: current_usuario, estado: 'creado')
            end
            return orden
        end
        nil
    end


Crear la ruta para el carrito:
app/config/routes.rb

resources :carros, only: [:show, :update]

En el views/home/index.html.erb agregar debajo:

<%= form_for :carro, url: carro_path(0), method: :put do |f| %>
    <%= f.hidden_field :producto_id, value: producto.id %>
    <%= f.hidden_field :cantidad, value: 1 %>
    <%= f.submit 'Agregar al carrito üõí', class: 'btn btn-primary btn-sm' %>
<% end %>

Para que se pueda agregar al carro y luego que aparezca un mensaje.




Crearemos una vista nueva para el carro:
Creamos la carpeta carro y dentro el archivo show.html.erb para mostrar el contenido del carro:

views/carro/show.html.erb


<div class="card">
    <div class="card-header bg-dark text-light">
        <i class="fa fa-shopping-cart" aria-hidden="true"></i>
        <a href="<%= root_url%>" class="btn btn-outline-info btn-sm pull-right">Continuar comprando</a>
        <div class="clearfix"></div>
    </div>
    <div class="card-body">
        <% @orden.detalles_ordenes.includes(:producto).each do |item| %>
            <div class="row">
                <div class="col-xs-2 col-md-2">
                    <img class="img-responsive" src="http://placehold.it/120x80" alt="prewiew">
                </div>
                <div class="col-xs-4 col-md-6">
                    <h4 class="product-name"><strong>
                            <%= item.producto.nombre %>
                        </strong></h4>
                    <h4><small>
                            <%= item.producto.descripcion %>
                        </small></h4>
                </div>
                <div class="col-xs-6 col-md-4 row">
                    <div class="col-xs-6 col-md-6 text-right" style="padding-top: 5px">
                        <h6><strong>
                                <%= item.precio %> <span class="text-muted">x</span>
                            </strong></h6>
                    </div>
                    <div class="col-xs-4 col-md-4">
                        <%= item.cantidad %>
                    </div>
                    <div class="col-xs-2 col-md-2">
                    </div>
                </div>
            </div>
            <hr>
            <% end %>
    </div>
    <div class="card-footer">
        <a href="#" class="btn btn-success pull-right">Pay</a>
        <div class="pull-right" style="margin: 5px">
            Total: $<b>
            <%= @orden.total %>
            </b>
        </div>
    </div>
</div>


######

¬øQue pasa si agrego 2 veces el mismo producto?
Me aparece el mismo producto 2 veces. 
Adem√°s el total de la compra no se est√° calculando.






###################### MEDIOS DE PAGO ########################




rails g model MetodoPago nombre:string codigo:string
rails db:migrate

rails g model Pago estado:string total:decimal token:string orden:references metodo_pago:references 
rails db:migrate

Finalizar asociaciones en models:

app/models/pago.rb

class Pago < ApplicationRecord
  belongs_to :orden
  belongs_to :metodo_pago
end

app/models/orden.rb

 has_many :pagos
has_many :metodos_pago, through: :pagos

app/models/metodo_pago.rb

class MetodoPago < ApplicationRecord
    has_many :pagos
    has_many :ordenes, through: :metodos_pago
end


Crear en add/seeds el archivo metodos_pago.rb y en √©l crear la f√≥rmula para relacionar con Paypal

MetodoPago.create(nombre: 'Paypal Express Checkour', codigo: 'PEC')



Instalar gema: gem 'dotenv-rails', groups: [:development, :test]  
#para las opciones de pago
bundle

Luego en config/environment/development.rb agregar:

config.after_initialize do
    ActiveMerchant::Billing::Base.mode = :test
    paypal_options = {
      login: ENV['PAYPAL_LOGIN_EMAIL'],
      password: ENV['PAYPAL_PASSWORD'],
      signature: ENV['PAYPAL_SIGNATURE']
    }
    ::EXPRESS_GATEWAY = ActiveMerchant::Billing::PaypalExpressGateway.new(paypal_options)
  end

  al final. 



Modificar show de views/carros

<div class="card">
    <div class="card-header bg-dark text-light">
        <i class="fa fa-shopping-cart" aria-hidden="true"></i>
        <a href="<%= root_url%>" class="btn btn-outline-info btn-sm pull-right">Continuar comprando</a>
        <div class="clearfix"></div>
    </div>
    <div class="card-body">
        <% @orden.detalles_ordenes.includes(:producto).each do |item| %>
            <div class="row">
                <div class="col-xs-2 col-md-2">
                    <img class="img-responsive" src="http://placehold.it/120x80" alt="prewiew">
                </div>
                <div class="col-xs-4 col-md-6">
                    <h4 class="product-name"><strong>
                            <%= item.producto.nombre %>
                        </strong></h4>
                    <h4><small>
                            <%= item.producto.descripcion %>
                        </small></h4>
                </div>
                <div class="col-xs-6 col-md-4 row">
                    <div class="col-xs-6 col-md-6 text-right" style="padding-top: 5px">
                        <h6><strong>
                                <%= item.precio %> <span class="text-muted">x</span>
                            </strong></h6>
                    </div>
                    <div class="col-xs-4 col-md-4">
                        <%= item.cantidad %>
                    </div>
                    <div class="col-xs-2 col-md-2">
                    </div>
                </div>
            </div>
            <hr>
            <% end %>
    </div>
    <div class="card-footer">
        <%= form_for :carro, url: pagar_con_paypal_carro_path(0) do |f| %>
            <%= f.hidden_field :orden_id, value: @orden.id %>
            <%= f.submit 'Pagar', class: 'btn btn-primary btn-sm' %>
        <% end %>

        <div class="pull-right" style="margin: 5px">
            Total: $<b>
            <%= @orden.total %>
            </b>
        </div>
    </div>
</div>



Agregar a app/controllers/carros_controller.rb

 # POST
    def pagar_con_paypal
        orden = Orden.find(params[:carro][:orden_id])
        #price must be in cents
        price = 100
        # Aqui llamamos al express gateway que definimos al inicializar
        # que definimos en nuestro archivo config/development.rb y
        # preparamos la compra, donde se nos devolver√° un token para
        # identificar esta venta en particular
        response = EXPRESS_GATEWAY.setup_purchase(price,
            ip: request.remote_ip,
            return_url: procesar_pago_paypal_carro_url,
            cancel_return_url: root_url,
            allow_guest_checkout: true,
            currency: "USD"
        )
        payment_method = MetodoPago.find_by(codigo: "PEC")
        # Aqu√≠ creamos nuestro registro en la tabla Payment con el
        # payment method de Paypal, y con estado ‚Äúprocessing‚Äù pues a√∫n
        # est√° en proceso
        Pago.create(
            orden_id: orden.id,
            metodo_pago_id: payment_method.id,
            estado: "processing",
            total: orden.total,
            token: response.token
        )
        # redirigimos al usuario a Paypal, para que realice el pago
        redirect_to EXPRESS_GATEWAY.redirect_url_for(response.token)
    end
    
    # GET
    def procesar_pago_paypal
        details = EXPRESS_GATEWAY.details_for(params[:token])
        express_purchase_options =
        {
            ip: request.remote_ip,
            token: params[:token],
            payer_id: details.payer_id,
            currency: "USD"
        }
        price = details.params["order_total"].to_d * 100
        response = EXPRESS_GATEWAY.purchase(price, express_purchase_options)
        if response.success?
            payment = Pago.find_by(token: response.token)
            order = payment.orden
            #update object states
            payment.estado = "completed"
            order.estado = "completed"
            ActiveRecord::Base.transaction do
                order.save!
                payment.save!
            end
        end
    end


PRUEBAS DE CREDENCIALES DE PAYPAL
Crear archivo .env y agregar:

PAYPAL_LOGIN_EMAIL=sb-xglup18801433_api1.business.example.com
PAYPAL_PASSWORD=3DKKCT8ZRK28GL4H
PAYPAL_SIGNATURE=A-Er.vf-9ZRNVhEXF4593mKl2H5JA.vtmLYJbbI7cPWOrcBEjPbrJaO.

